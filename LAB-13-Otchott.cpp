Лабораторная работа №13
Кодирование алгоритмов сортировки с оценкой их
производительности
Цель работы: Изучить принципы сортировки массивов различными
методами. Рассмотреть схемы сортировок. Разобрать приведенные примеры
и выполнить самостоятельно один или более вариантов заданий.
Теоретические сведения
Наиболее частыми операциями при работе с данными являются
«поиск» и «сортировка». При этом алгоритмы решения этих задач
существенно зависят от того, организованы записи в массивы или размещены
на диске.
Методы сортировки классифицируются по времени их работы.
Хорошей мерой эффективности может быть число сравнений ключей - С и
число пересылок элементов - Р. Эти числа являются функциями С(n), Р(n) от
числа сортируемых элементов n. Быстрые (но сложные) алгоритмы
сортировки требуют (при n??) порядка n log n сравнений, прямые
(простые) методы -n2.
Прямые методы коротки, просто программируются, быстрые,
усложненные, методы требуют меньшего числа операций, но эти операции
обычно сами более сложны, чем операции прямых методов, поэтому для
достаточно малых n (n?50) прямые методы работают быстрее. Значительное
преимущество быстрых методов (в n/log(n) раз) начинает проявляться при
n? ? 100.
Среди простых методов наиболее популярны:
1) Метод прямого обмена
2) Метод прямого выбора:
Реже используются:
3) Сортировка с помощью прямого (двоичного) включения;
4) Шейкерная сортировка (модификация пузырьковой).
Улучшенные методы сортировки:
1) Метод Д. Шелла, усовершенствование метода прямого включения.
2) Сортировка с помощью дерева, метод HeapSort, Д. Уильямсон.
3) Сортировка с помощью разделения, метод QuickSort, Ч. Хоар,
улучшенная версия пузырьковой сортировки. На сегодняшний день это
самый эффективный метод сортировки.
Сравнение методов сортировок показывает, что при n > 100 наихудшим
является метод пузырька, метод QuickSort в 2-3 раза лучше, чем HeapSort, и в
3-7 раз, чем метод Шелла.

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
int random(int N){
    return rand()%N;
}
int main(){
    int i,j,A[90],B[90],C[90],X,flag=0,n=-1,min,c,Z,k,count=0;
    printf("enter Z");
    scanf("%d",&Z);  
    for(i=0;i<Z;i++){
        
        B[i]=A[i]=random(450);
        printf("%7d",A[i]);
    }
   printf("Enter X:");
    scanf("%d",&X);
    for(i=0;i<Z;i++){
    if(A[i]==X) n=i;}
        
        
   if(n>0)    
         printf("i= %5d\n",n+1);
    else  printf("error");
    
    
    
      
      for(i=0;i<Z;i++){ 
      if(i<n) B[i]=0;
      C[i]=B[i];
     }
      
      printf("\n");
    
    for(i=0;i<Z;i++){ 
      if(i>=n&&A[i]!=0){ 
      printf(" %d  ",A[i]);
	  
	  
	  
	  }}
	  
        
     
        
        

    
    for(i=0;i<Z-1;i++){
   int  min=i;
    for(int j=i+1;i<Z;j++)
      if(C[j]<C[min])
	  
        min=j;
       if(min!=i){
        c=C[i];C[i]=C[min];C[min]=c;        
            }     
    
    for(i=0;i<Z;i++){
        if(C[i]!=0){
    printf("  %d  ",C[i]);}}}}



